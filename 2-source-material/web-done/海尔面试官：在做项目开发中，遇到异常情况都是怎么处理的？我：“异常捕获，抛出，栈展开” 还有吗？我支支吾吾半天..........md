> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_6a_nx1tGA63pPRc0uL_1A)

![](https://mmbiz.qpic.cn/mmbiz_png/jwOoqvGmyhaff3s6pPbnOOSPCdHLovWe2WvAnTGbiaapyRtuhibA2nGMNibMWDoB37Y55dDbeM6icCmMuBzsKEn9ibQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&tp=webp#imgIndex=0)

最强八股文，就在卡码笔记：[https://notes.kamacoder.com/](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247521125&idx=1&sn=23470029dd400b13497d83b4382996d7&scene=21#wechat_redirect)

  

面试时没有回答好问题是很正常的，被面试官质疑时，要有今天不会明天会的底气，面后做好复盘，不在同一道题目上跌倒第二次，今天就从 C++ 中的异常处理机制背起来

海尔专业一面 " 介绍一下 C++ 中的异常处理机制 "（下文知识图解部分提供了演示图例）

#### 简要回答

C++ 异常处理基于 **try-throw-catch 机制**，提供结构化的错误处理方式。

**try 块定义监控范围，throw 抛出异常对象，catch 捕获并处理异常**。

**支持异常类型**匹配、**栈展开**和**资源自动清理**，通过 **RAII 保证异常安全**。

#### 详细回答

C++ 异常处理核心组件：

1. **异常抛出**（throw），使用 throw 表达式抛出异常对象），可以抛出任意类型的对象（内置类型、自定义类、标准异常等），**抛出异常会**立即**终止当前函数**执行

2. **异常捕获（catch）**，catch 块**按顺序**匹配异常类型，支持异常类型继承层次中的**多态捕获**，可以使用 catch(...) 捕获所有异常

3. **栈展开（Stack Unwinding）**，从**抛出点**开始**向上查找匹配的 catch 块**，自动**调用局部对象**的析构函数，保证资源正确释放

4. **异常规格（Exception Specifications）**，C++11 引入 **noexcept 说明符**，替代**旧的动态异常规格**，提供编译期异常保证

#### 代码示例

基本的异常处理示例

```
#include <iostream>
#include <stdexcept>
#include <string>

// 自定义异常类
class MyException :publicstd::exception {
private:
    std::string message;
    
public:
    MyException(conststd::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

double divide(double a, double b) {
    if (b == 0) {
        throwstd::invalid_argument("Division by zero!");
    }
    return a / b;
}

void process_data(int value) {
    if (value < 0) {
        throw MyException("Negative value not allowed: " + std::to_string(value));
    }
    if (value > 100) {
        throwstd::out_of_range("Value too large: " + std::to_string(value));
    }
    std::cout << "Processing value: " << value << std::endl;
}

void basic_exception_demo() {
    try {
        std::cout << "10 / 2 = " << divide(10, 2) << std::endl;
        std::cout << "10 / 0 = " << divide(10, 0) << std::endl;  // 这里会抛出异常
    }
    catch (conststd::invalid_argument& e) {
        std::cout << "Caught invalid_argument: " << e.what() << std::endl;
    }
    
    try {
        process_data(50);   // 正常
        process_data(-5);   // 抛出MyException
        process_data(200);  // 不会执行到这里
    }
    catch (const MyException& e) {
        std::cout << "Caught MyException: " << e.what() << std::endl;
    }
    catch (conststd::exception& e) {
        std::cout << "Caught std::exception: " << e.what() << std::endl;
    }
    catch (...) {
        std::cout << "Caught unknown exception" << std::endl;
    }
}


```

文件管理中的 RAII noexcept 和异常的安全保证

```
#include <iostream>
#include <vector>

class NoExceptDemo {
public:
    // 基本不抛出异常的函数
    int get_value() const noexcept {
        return42;
    }
    
    // 可能抛出异常的函数
    void risky_operation() {
        throwstd::runtime_error("This might fail");
    }
    
    // 移动构造函数通常标记为noexcept
    NoExceptDemo(NoExceptDemo&& other) noexcept {
        std::cout << "Move constructor (noexcept)" << std::endl;
    }
    
    // 析构函数不应该抛出异常
    ~NoExceptDemo() noexcept {
        std::cout << "Destructor (noexcept)" << std::endl;
    }
};

void noexcept_usage() {
    NoExceptDemo demo;
    
    // noexcept运算符检查表达式是否可能抛出异常
    std::cout << "get_value is noexcept: " << noexcept(demo.get_value()) << std::endl;
    std::cout << "risky_operation is noexcept: " << noexcept(demo.risky_operation()) << std::endl;
    
    // 在vector重新分配时，noexcept移动构造函数更高效
    std::vector<NoExceptDemo> items;
    items.push_back(NoExceptDemo());  // 优先使用移动构造
}


```

#### 知识拓展

*   知识图解
    

![](https://mmbiz.qpic.cn/mmbiz_png/jwOoqvGmyhYuscMngOib5pteA7o8nZZu8fWribc8mQvz1g4P0oSd9NvgIh8dTctpO5wPAG4Oiaz1iaLJCwaLPF7e5A/640?wx_fmt=png&from=appmsg#imgIndex=1) image

*   适用场景
    

不可恢复错误 - 内存分配失败、硬件错误等

构造函数失败 - 对象构造无法完成时

资源获取失败 - 文件打开、网络连接等

逻辑错误 - 违反前置条件、无效参数等

跨多层调用错误处理 - 错误需要向上传递多级时

*   面试官很能追问
    

Q1: 异常处理相比返回错误码有什么优势？

A1: 分离错误处理：正常逻辑和错误处理代码分离，提高可读性

自动传播：异常自动向上传播，无需每层检查错误码

类型安全：异常是类型安全的，编译器可以检查类型匹配

无法忽略：未处理的异常会导致程序终止，错误不会被静默忽略

构造函数支持：构造函数无法返回错误码，只能使用异常报告失败

Q2: 什么是栈展开？在异常处理中起什么作用？

A2: 栈展开是从异常抛出点开始，沿着调用链向上查找匹配 catch 块的过程。在这个过程中：

自动调用局部对象的析构函数

释放自动存储期的资源

维护调用栈的完整性

保证资源不泄漏（结合 RAII） 栈展开确保了即使发生异常，程序也能正确地清理资源。

Q3: 为什么应该按引用捕获异常？

A3: 按引用捕获异常有多个优势：

避免切片：捕获派生类异常时保持多态性

避免拷贝：不需要复制异常对象，提高性能

保持原始异常：能够重新抛出原始异常对象

一致性：与标准库异常处理方式一致

Q4: 在析构函数中抛出异常会有什么问题？

A4: 在析构函数中抛出异常是危险的，因为：

双重异常：如果栈展开过程中析构函数抛出异常，会立即调用 terminate

资源泄漏：可能中断其他资源的清理过程

未定义行为：C++ 标准规定这种情况会导致程序终止

最佳实践：析构函数应该用 noexcept 声明，并吞掉所有异常

八股文训练营在今天（10 月 29 日）开营，目前可以报名
-----------------------------

### 为什么有八股文训练营

现在八股文（面试题）的资料非常多，但大家平时背诵八股文的时候依然有如下烦恼：

1.  八股文内容太多了，有限的时间内，应该看哪些题
    
2.  感觉内容学不完，自己学习没有节奏感
    
3.  **八股看了很多，但面试中自己说不出来**
    
4.  面试的时候紧张：我是谁，我在哪，我在干什么
    

为了**避免大家面试的时候 “口吃”，说话不利索**，**卡码训练营开辟一种全新的训练营模式即录音打卡！**

 每日给出八股任务，要求大家在系统上录音回答问题，才算完成今日打卡。  

详情看这里：********[面试突击（八股文）训练营详情](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247520019&idx=4&sn=5b08ed5491cea563f46c1fb9fc237896&scene=21#wechat_redirect)******** 

********拼单购买优惠 20 元，可以提前加入拼单群：********

********![](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv56BlXpP4yhEOMY9aaTNSMeB5zOfp7qTqHhwaiaJSlkNIzvg3AvfsMfW1LDibRpYkyF1AUKfLNRVuPw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&randomid=fns5td0t&tp=webp#imgIndex=2)********

### 八股训练营的效果

这是往期录友们的反馈：

![](https://mmbiz.qpic.cn/mmbiz_png/jwOoqvGmyhZYd7k44MdAt7DOCJxhE09FIaq5icLPPXibUqqg8HZJPuU5GAc7fjMSjeL1LKW6qRWbic4KYUmHG1BHw/640?wx_fmt=other&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&randomid=ulg5w0nk&tp=webp#imgIndex=3)

### 查看开营时间和报名训练营

微信扫码查看最近训练营开营时间：在今天（10 月 29 日）开营，目前可以报名  
![](https://mmbiz.qpic.cn/mmbiz_png/jwOoqvGmyhZYd7k44MdAt7DOCJxhE09FHUO84gOZwvnGhEreEFLwvP1gpL6CF2lLGMX0UomxrHPmicxUsT3Iz9A/640?wx_fmt=other&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1&randomid=8khqfuov&tp=webp#imgIndex=4)

关于训练营的任何疑问都可以扫码联系客服，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/jwOoqvGmyhbdHf4ncibickT7xW1Whp13YGjzCNzicEd8BLMqP30xjEWuXdv5UOWwU8gbhIAtY1bq0icicqnwh0Awqrw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&randomid=wjbpczo5&tp=webp#imgIndex=5)

欢迎录友们来做笔记，点击「**阅读原文**」，可直达【**卡码笔记**】