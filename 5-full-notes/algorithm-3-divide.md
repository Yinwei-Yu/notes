Time:2025-09-22

Status: 

- [ ] **working** 👨‍💻
- [x] *done*    💻

Tags:[[3-tags/algorithm|algorithm]]

## 引言

*二分查找*

折半找，每次节省1/2成本

---

*归并排序*

1. 将数组分为两个各一半元素的数组
2. 对两个数组分别排序
3. 合并两个数组

## Main Idea

1. 分解:原问题分解为若干个规模较小,相互独立,与原问题形式相同的子问题
2. 求解子问题:容易则直接解,否则递归解
3. 合并
## 寻找第k小元素

在包含n个元素的集合中找到第k个最小的元素
直观:nlogn排序后返回即可
能否降低到O(n)?

---

在递归算法中,如果每次递归都能丢弃元素的一个固定部分,也就是说问题的规模以几何级数的速度降低,那么最终问题的时间复杂度可以降低到O(n):

![[2-source-material/images/Pasted image 20250927170837.png]]

---

由此可以先得到算法的思路:

1. 如果元素的个数小于某个阈值,44,那么直接排序后返回A\[k]
2. 否则,将n个元素划分为5个一组,总共有n/5组
3. 对每个组中的5个元素排序,然后找出中位数,也就是第3个元素
4. 然后找到这些中位数中的中位数,mm
5. mm将数组划分为三个部分,A1,A2,A3;分别包含小于,等于,大于mm的元素
6. 根据三个子数组的长度,分别选择返回第k小元素,或者递归

对于A1,A2,A3三个数组,做进一步说明:

1. 若|A1|>=k,说明第k小的元素在A1中,在A1中递归调用即可
2. 若|A1|+|A2|>=k,说明第k小的元素在A2中,而A2中都是等于mm的元素x0,因此直接返回x0即可
3. 若两个都不满足,那么要在A3中递归查找,此时需要查找的数组变为A3,需要寻找到元素也变为第k-|A1|-|A2|小的元素

上述的1,2条,就是前面提到的每次递归中丢弃一部分元素的思路.为了验证复杂度,需要看这里丢掉了多少元素,也就是说,剩下的|A1|和|A3|的上界是多少.

---

![[2-source-material/images/Pasted image 20250927181241.png]]

由于A1'至少与W一样大,我们有:
$$
|A1'|\geq 3 \lceil \lfloor \frac {n/5}{2} \rfloor \rceil \geq \frac{3}{2}\lfloor n/5 \rfloor
$$
因此|A3|即为n减去|A1'|:
$$|A_3|\leq n-\frac{3}{2}\lfloor n/5\rfloor\leq n-\frac{3}{2}\left(\frac{n-4}{5}\right)=n-0.3n+1.2=0.7n+1.2$$
由参数对称可得,|A1|也满足$0.7n+1.2$的上界,因此,在每次递归后,都会丢掉3/10的元素.

---

伪代码:

![[2-source-material/images/Pasted image 20250927182043.png]]

其中需要解释,如何通过七次比较,找到一个包含五个元素的集合的中位数:

假设有五个数:a,b,c,d,e:

先不管e,对a,b,c,d四个数比较,确定他们的顺序关系,这里采用分治法,至少需要5次比较:

1. ab比较,cd比较  得到两个小值和两个大值,假设分别为:b,c;a,d
2. 两个小值和两个大值分别比较,得到确定的关系,假设b>c,a>d,那么我们有:$$c<b,d<a$$
3. 由于我们只知道d和c的大小关系,所以不能确定d和b的大小关系,所以这里还需要一次比较,最终,得到:$$c<b<d<a$$
接下来,将e与b或者d进行比较:

4. 若e<b,那么b为中位数,此时比较次数为6
5. 若e>b,那么需要比较e和d的大小,如果e<d,则e为中位数,否则d为中位数.此时需要7次比较

---

复杂度分析:

根据伪代码,可以得到:
$$
T(n)=T(\frac{n}{5})+T(\frac{7n}{10})+\Theta(n)
$$
关键是该式如何解

根据上面提到的分治后丢到一部分元素最后是一个几何级数:
采用递归树法:
第一层的开销为$\Theta(n)$
第二层的开销为$\Theta(n/5)+\Theta(7n/10)=\Theta(9n/10)$
第三层的开销为$\Theta(n/25)+\Theta(7n/50)+\Theta(7n/50)+\Theta(49/100)=\Theta(81n/100)$
可以看到每层的开销都为上一层的9/10,
则我们有:

$$
T(n)=\sum\limits_{k=0}^\infty c(\frac{9n}{10})^k=cn\sum \limits_{k=0}^\infty (\frac{9}{10})^k = 10cn
$$
因此,$T(n)=\Theta(n)$

## 大整数乘法

假设u和v都为n位二进制整数,要计算乘积u\*v,按照常规方法,需要对每两个二进制位做加法,总共需要$O(n^2)$步运算.

如果采用分治:

![[2-source-material/images/Pasted image 20250927191613.png]]

复杂度没变,是否能够利用已经计算出的结果来替换一些计算?

![[2-source-material/images/Pasted image 20250927191723.png]]

## 矩阵乘法

同样是利用部分算出的结果进行加减来减少乘法操作

## 最近点对问题

设S为平面上n个点的集合,需要找一个点对p和q,使得这两个点之间的距离最小.

1. 将点按照x坐标进行排序,找到一条中间的线,将点分为两个部分$S_l$和$S_r$
2. 分别对两个子集求最小间距,得到两个最小间距:$\delta_l,\delta_r$
3. 求出$S_l$和$S_r$之间的最小间距$\delta'$,返回三个距离中的最小值.

---

如何高效求出$\delta'$?

![[2-source-material/images/Pasted image 20250927192420.png]]

这张slide限制了待定点的一个范围

![[2-source-material/images/Pasted image 20250927192638.png]]

进一步限制需要进行比较的候选点的个数

**对4的说明:**

![[2-source-material/images/Pasted image 20250927192722.png]]

---

伪代码:

![[2-source-material/images/Pasted image 20250927193602.png]]
![[2-source-material/images/Pasted image 20250927193606.png]]

## Reference
