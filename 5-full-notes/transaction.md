Time:2025-10-28

Status: 

- [ ] **working** 👨‍💻
- [x] *done*    💻

Tags:[distributed](3-tags/distributed.md)

# lecture notes
## 分布式事务本质

- 定义：**分布式事务 = 并发控制 + 原子提交**，需同时保证 “多分片操作无并发干扰” 与 “故障下操作全有或全无”；
- 应用价值：为开发者屏蔽 “跨分片操作交错” 与 “服务器故障” 的复杂性，典型场景包括银行转账（跨分片扣款 + 入账）、社交图谱双向关联（跨分片写两条关联记录）、插入记录 + 更新索引（跨分片数据与索引存储）。

## 事务正确性标准：ACID 特性

ACID 四特性定义

| 特性              | 核心要求                         | 作用场景                     |
| --------------- | ---------------------------- | ------------------------ |
| 原子性（Atomic）     | 无论是否故障，所有写操作要么全部执行，要么全部不执行   | 服务器崩溃、网络中断等故障场景          |
| 一致性（Consistent） | 事务执行后数据满足应用特定不变性约束（如银行总资金守恒） | 保证业务逻辑正确性，由应用定义 + 系统辅助实现 |
| 隔离性（Isolated）   | 事务间无干扰，执行效果等效于串行执行（可序列化）     | 多事务并发访问同一分片 / 跨分片数据      |
| 持久性（Durable）    | 已提交的写操作永久有效，不会因后续故障丢失        | 提交后服务器崩溃、数据存储介质临时异常      |


# 原子性与分布式两阶段提交协议
## 一、原子性核心概念与基础应用
### （一）原子性的本质与核心表现

原子性是计算机系统保证数据一致性与并发正确性的核心特性，本质是 **“隐藏操作内部结构”** 的强模块化能力 ，从不同视角可分为两种关键表现：
1. **全有或全无（All-or-Nothing）**：针对故障恢复场景，操作要么完整执行并产生预期效果，要么完全不执行（如服务器崩溃后，未完成的转账操作无任何影响）；
2. **要么全前要么全后（Before-or-After）**：针对并发协调场景，多线程对共享数据的操作等效于串行执行，无步骤交错（如多线程打印任务无内容混杂）。

### （二）并发协调的正确性标准：可序列化

可序列化（Serialization）是判断并发原子性是否正确的通用标准，定义为“并发操作的结果，一定等效于这些操作以某种纯串行顺序执行的结果”。其核心推理逻辑基于“系统状态转换”：
- 单个操作独立执行时，能将正确初始状态转换为正确新状态；
- 并发操作的最终状态需与某一串行顺序的最终状态一致，中间状态可不可见；
- 部分场景需更强约束（如外部时间一致性：操作实际结束时间顺序需与序列化顺序一致）。

## 二、原子性的本地实现：锁定规则

锁定规则是实现“要么全前要么全后原子性”的本地核心方案，通过锁管理器控制共享数据访问，确保可序列化，主要包括两种经典规则：

并发控制的两类方案

| 方案类型        | 核心逻辑                 | 冲突处理      | 适用场景                    |
| ----------- | -------------------- | --------- | ----------------------- |
| 悲观并发控制      | 操作数据前先获取锁，禁止其他事务同时操作 | 冲突事务等待锁释放 | 事务冲突频繁（如高并发转账）          |
| 乐观并发控制（OCC） | 无锁操作数据，提交时验证是否满足可序列化 | 冲突事务中止并重试 | 事务冲突稀少（如低并发数据查询 + 少量写入） |
### （一）简单锁定（Simple Locking）
1. **核心规则**：
   - 锁获取：事务执行前，批量获取所有意图访问（读/写）共享对象的锁；
   - 锁释放：仅在事务提交/中止后，一次性释放所有锁。
2. **关键概念**：
   - 锁点（Lock Point）：事务首次获取所有所需锁的瞬间，是执行读/写操作的分界点；
   - 锁集（Lock Set）：事务到达锁点时已获取的所有锁的集合，固定不变。
3. **适用场景**：事务逻辑简单、可提前确定所有访问对象（如银行转账仅访问扣款与收款账户）。

### （二）两阶段锁定（Two-Phase Locking, 2PL）
1. **核心规则（分两阶段）**：
   - 加锁阶段（Growing Phase）：事务执行中按需动态获取锁，仅加锁不释放；
   - 解锁阶段（Shrinking Phase）：到达锁点（确定不再加锁）后，仅释放锁不加锁（未修改对象可提前释放，修改对象需持至结束）。
2. **优势与局限**：
   - 优势：灵活性高，无需提前确定所有访问对象，并发性能优于简单锁定；
   - 局限：正确性证明复杂，仍会错失部分可序列化顺序，理论上无法覆盖所有可序列化场景（NP完全问题）。
3. **适用场景**：事务逻辑复杂、无法提前确定访问对象（如电商订单处理：需先读购物车动态确定商品，再访问库存）。

## 三、重点：分布式两阶段提交协议（Distributed 2PC）
### （一）协议背景与核心目标

1. **应用场景**：多站点事务（事务需在多个通过“尽力而为网络”连接的站点执行组件事务），如跨分行转账、跨区域库存同步；
2. **核心挑战**：网络不可靠（消息丢失/延迟/重复）、站点独立性（无法直接感知其他站点状态），需避免“部分站点提交、部分中止”的不一致；
3. **基础假设**：每个站点已实现单站点原子性（通过版本历史/日志实现全有或全无，通过锁实现要么全前要么全后）；
4. **核心目标**：确保所有参与站点“要么全部提交，要么全部中止”，实现多站点事务的“全有或全无”原子性。

### （二）核心角色

1. **协调者（Coordinator）**：发起并协调整体事务，决定最终结果（提交/中止），如文档中的“Alice”；
2. **工作者（Worker）**：执行本地组件事务，反馈执行状态，按协调者指令完成提交/中止，如文档中的“Bob（执行X）、Charles（执行Y）、Dawn（执行Z）”。

### （三）完整协议流程（含异常处理）
#### 1. 前置准备：嵌套事务与初始通信

- 协调者创建“顶层事务结果记录”，通过**持久化发送者**向工作者发送组件事务请求（如“执行X作为事务271的一部分”），未收到响应则重复发送；
- 工作者进行去重检查，创建“嵌套事务”（关联顶层事务），执行预提交前操作，反馈“已准备好提交”。

#### 2. 第一阶段：预准备（Prepare）——确认可提交性

- **协调者行动**：收集所有工作者“已准备好”响应后，向每个工作者发送“PREPARE消息”（如“准备提交X”）；
- **工作者行动**：
  - 执行本地预提交：创建持久化临时版本/记录更新日志，标记状态为“PREPARED（已准备提交）”；
  - 通过持久化发送者反馈“PREPARED”（或“ABORTED”），进入悬置状态（无法单方面中止，需等待最终指令）；
- **协调者判断**：
  - 所有工作者反馈“PREPARED”→进入第二阶段；
  - 任一反馈“ABORTED”或超时→选择中止事务或更换工作者。

#### 3. 第二阶段：提交/中止（Commit/Abort）——统一执行

- **情况1：决定提交**：
  - 协调者：标记顶层记录为“COMMITTED”，向所有工作者发送“提交消息”；
  - 工作者：状态更新为“COMMITTED”，执行提交后操作（写入正式存储、释放锁），结束事务。
- **情况2：决定中止**：
  - 协调者：标记顶层记录为“ABORTED”，向所有工作者发送“中止消息”；
  - 工作者：状态更新为“ABORTED”，执行回滚（删除临时版本、恢复数据），结束事务。

#### 4. 异常处理机制

- **消息丢失处理**：
  - 工作者未收到最终指令→重复发送“PREPARED”，直至收到协调者响应；
  - 协调者收到重复“PREPARED”→再次发送最终状态（提交/中止）。
- **工作者崩溃恢复**：
  1. 重启后从日志/版本历史恢复“PREPARED事务”，还原状态；
  2. 若用锁机制，重新获取事务持有的锁；
  3. 重启持久化发送者，向协调者获取最终状态，完成后续操作。
- **协调者单点故障**：协调者崩溃（如发送PREPARE后未发最终指令）→所有工作者长期悬置，需等待协调者恢复（协议未解决该问题）。

### （四）协议优化与局限性
#### 1. 消息开销与优化变种
| 优化方案 | 核心逻辑 | 优势 | 局限 |
|----------|----------|------|------|
| 基础3N消息 | 每个工作者3条消息（PREPARE→PREPARED→COMMIT/ABORT） | 流程简单，易实现 | 消息次数固定，无优化 |
| 合并初始请求与PREPARE | 将组件事务请求与PREPARE合并为1条消息 | 减少消息次数 | 需确保协调者确认所有工作者就绪后发送，避免工作者长期悬置 |
| 增加第四轮确认 | 工作者完成提交/中止后，向协调者反馈确认 | 协调者可安全删除顶层记录 | 增加N条消息开销 |
| 预设提交（Presumed Commit） | 用“记录不存在”表示COMMITTED，仅保留ABORTED记录 | 减少存储与消息开销 | ABORTED记录需等待所有确认后删除，否则查询易误判 |

#### 2. 核心局限性

- **单点故障**：协调者是唯一决策源，崩溃后事务阻塞，影响可用性；
- **无法解决两将军困境**：不可靠网络下，无法确保所有站点“同时”知晓最终状态，仅能保证“最终”一致性；
- **长期悬置风险**：工作者进入PREPARED状态后，若协调者长期不可用，将持续占用资源（如锁、临时存储）。
- 性能瓶颈：多轮消息交互（PREPARE→YES→COMMIT→确认）+ 磁盘持久化（参与者 YES 前、TC COMMIT 前），延迟较高；
- 锁阻塞：参与者从 PREPARE 到 COMMIT/ABORT 期间需持有锁，TC 崩溃可能导致锁长期占用，阻塞其他事务；
- 可用性低：需所有参与者存活才能推进，任一参与者故障可能导致事务阻塞；
- 应用范围：仅适用于 “单一小型域”（如企业内部分片数据库），不适用于跨银行、广域网等场景。

#### 3. 高可用优化方案

- 核心思路：将 TC 与参与者均通过 Raft 协议实现副本复制，构建高可用的 TC 集群与参与者集群；
- 执行逻辑：在 Raft 复制后的服务间运行 2PC，即使部分节点崩溃，集群仍可推进事务；
- 典型案例：Google Spanner（后续课程讲解），通过 Raft 复制解决 2PC 的单点故障问题。

#### 4. 关键技术对比：2PC vs Raft

|对比维度|两阶段提交（2PC）|Raft|
|---|---|---|
|解决问题|多参与者执行不同操作的原子性（全提交或全中止）|多副本执行相同操作的高可用性（多数副本存活即可推进）|
|执行逻辑|参与者执行不同任务（如 A 扣钱、B 加钱）|所有副本执行相同任务（如均写入某条记录）|
|可用性|需所有参与者存活，可用性低|仅需多数副本存活，可用性高|
|原子性保障|保证 “所有参与者要么均执行，要么均不执行”|保证 “多数副本执行相同操作”，不保证所有副本执行|
## 四、知识体系关联总结
| 层级 | 核心内容 | 解决的问题 | 关键技术 |
|------|----------|------------|----------|
| 原子性概念层 | 全有或全无、要么全前要么全后；可序列化标准 | 定义原子性本质与正确性判断依据 | 状态转换模型 |
| 本地实现层 | 简单锁定、两阶段锁定 | 单站点内并发事务的原子性 | 锁管理器、锁点/锁集 |
| 分布式实现层 | 分布式两阶段提交协议 | 多站点事务的原子性（跨网络协调） | 持久化发送者、去重、嵌套事务 |

分布式两阶段提交协议是“本地锁定规则”在多站点场景的延伸，通过分阶段确认与可靠通信，解决了网络不可靠下的原子性问题，是理解分布式一致性的基础；但其单点故障、两将军困境等局限，也推动了后续三阶段提交、Paxos、Raft等更优分布式协议的发展。

# FAQ

1. **事务与原子性：**
    - **核心定义：** 事务是多步操作的集合，必须具备**原子性**（全或无），即要么所有步骤成功，要么所有步骤失败，以确保数据**一致性**。
    - **编程简易性：** 事务是简化并发和故障处理编程的抽象。
2. **并发控制机制：**
    - **可串行化（Serializability）：** 正确性的黄金标准，要求并发执行的结果等同于**某个**串行执行的结果。
    - **两阶段锁定（2PL）：** 一种**悲观**并发控制策略，通过锁来防止事务之间的**干扰**，但可能导致**死锁**（需检测和打破）。规则要求：在释放任何锁后，不得再获取新锁，且所有锁必须保持到**提交或中止**后才能释放（强严格 2PL），以确保可串行化。
3. **分布式容错与协调机制：**
    - **两阶段提交（2PC）：** 一种**分布式协调协议**，用于确保跨多台机器的事务的**原子性**（全部提交或全部中止）。它解决了**跨不同数据和不同机器**的协调问题。
    - **2PC 的挑战：** 协调者（TC）崩溃会造成工作节点**无限期地持有锁**，导致活锁（blocking）。
    - **Raft 与 2PC 的区别：** Raft 解决的是**副本之间**的**一致性**问题，2PC 解决的是**跨不同分区**的**原子性**问题。Raft 具有**可用性**，2PC 在协调者或参与者失败时会**阻塞**。
    - **三阶段提交（3PC）：** 试图提高 2PC 的**可用性**，但在**网络分区**下无法保证正确性，因此不常在实际网络中使用。
4. **底层实现工具：**
    - **日志（Logs）：** 是实现事务、确保顺序和崩溃恢复的关键工具，因其高效的**顺序写入**特性和便于追踪操作状态的能力而被广泛采用（**预写日志**）。
    - **锁管理器（Lock Manager）：** 专门负责管理锁的获取、释放和死锁检测。
## Reference
