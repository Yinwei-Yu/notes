Time:2025-09-26

Status: 

- [ ] **working** 👨‍💻
- [x] *done*    💻

Tags:[[3-tags/compile|compile]]

## 形式语言基础

*语法:怎么写*

由程序设计语言的基本符号组成程序中各个语法成分（包括最大的语法成分“程序”）的一组规则。
词法规则：由基本符号构成符号（单词）的书写规则
语法规则：由符号（单词）构成语法成分的规则
赋值语句的语法:
><赋值语句>：：=<变量><赋值号><表达式>

---

*语义:怎么做*

各个语法成分的意义,各语法成分在运行阶段被计算机执行时**所做的工作及其结果**

静态语义:编译时可确定的语法成分含义
动态语义:运行时刻才可以确定的
赋值语句的语义 ＜赋值语句>：：=<变量>＜赋值号><表达式> 
>先对语句的右部表达式求值，再把所得结果与语句左部的变量相结合，并取代该变量原有的值。

---

*语用:为什么*

符号的来源,使用,影响
赋值语句的语用:
  计算和保存表达式的值

## 文法和语言的形式定义

*why?*

文法描述的是高级语言程序的构成规则
文法必须精确,严格定义--形式化方法

---

*what?*

用一组**数学符号**和**规则**来描述语言的方式称为**形式描述**，而把所用的数学符号和规则称为**形式语言**

只是从语法上研究语言

最基本概念是**符号串和符号串集合**

---

*字母表*

是元素有穷非空的集合,字母表的元素称为符号

eg.
{a,b,...,y,z},{0,1}...

常用大写字母或者希腊字母表示字母表

一个程序设计语言只使用有限符号集作为字母表

---

*符号串*

字母表中的符号组成的任何有穷序列,不包含任何符号的符号串称为空串,记为$ε$

长度:符号串x中符号的个数,记为|x|
  空串是长度为0的串,不等于∅
  
连接:设 x、y 是同一字母表上的两个符号串，则把y的各个符号写在×的符号之后得到的符号串，称为×与y的连接，记作xy。

方幂:设× 是一个符号串，把× 自身连接n 次得到的新的符号串，即 z=xX..X（n个x），称为x的n次方幂，记作x。

集合的乘积:$AB = \{xy | x \in A,y \in B \}$

集合的方幂:$A^2=AA$

闭包:![[2-source-material/images/Pasted image 20250926162739.png]]

---

*串的各部分*

s = banana

串s的前缀（prefix）
  从s尾部删除0或多个符号后得到的串。如：ban,banana， &。
串s的后缀（suffix）
  从s的开始处删除0个或多个符号后得到的串。如：nana, banana，&。串s的子串（substring）
  删除s的某个前缀和后缀后得到的串。如：banana, nan, E。
串s的真（true）缀、真后缀、真子串
  s的既不等于，也不等于s本身的前缀、后缀和子串。
串s的子序列（subsequence）
  从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻。如：baan。

---

*形式语言*

字母表上符号串的任意集合

如何取出一个有意义的符号串?

## 文法的形式定义

*文法*

终结符号(terminal)/词法单元(token)
  终结符号->组成语言的基本符号:保留字,运算符,界限符等.
  终结符号是语言的不可再分的基本符号,终结符号的集合为 $V_T$
非终结符号(nonterminal)
  语言的语法成分,例如"赋值语句"
  其集合记为 $V_N$

$$V_T \cap V_N= \emptyset $$

---

*产生式*

是一个有序对(α,β),用来定义一个语法成分的形式规则

α->β or α::=β

α称为产生式的左部/头部
β:右部/体

$\alpha \in (V_T \cup V_N)^+$
$\beta \in (V_T \cup V_N)^*$

α是集合上的任意符号串，但必须至少包含一个非终结符，并且不能是空串
B是集合上的任意符号串，也可以是空串

$\alpha \rightarrow \beta_1 | \beta_2 | ...$

---

*文法的形式定义*

是产生式的有穷非空的集合

$$
G[S] = (V_N,V_T,P,S)
$$

$V_N$:非终结符号集
$V_T$:终结符号集
$P$:产生式的有穷非空集合
$S$:开始符号,至少在一条产生式中作为左部

---

*文法的分类*

0型文法 短语结构文法 Phrase Structure Grammar

1型文法 上下文有关文法 Context-Sensitive Grammar

2型文法 上下文无关文法 Context Free Grammar

3型文法 正规（正则）文法 Regular Grammar(重点看是不是只有一个终结符而且终结符的相对位置确定)

![[2-source-material/images/Pasted image 20250926170955.png]]

**上下文无关文法是上下文有关的特例**

## 语言的形式定义

语言是句子的集合,是字母表上符号串的集合

程序设计语言:符合该语言语法的程序的全体

---

*直接推导*

直接替换就完事儿了

逆过程叫做**直接规约**

---

*推导*

![[2-source-material/images/Pasted image 20250926174641.png]]

**从任意符号串开始的推导得到的符号串没有实际意义(推导要从开始符号出发)**

---

*语言*

![[2-source-material/images/Pasted image 20250926175602.png]]
![[2-source-material/images/Pasted image 20250926175621.png]]

\* 表示任意步推导(包括0步)

## 语法树

![[2-source-material/images/Pasted image 20251010085123.png]]

推导->语法树

开始符号作为根
每个直接推导作为一个分支
重复直到无分支可画

语法分析即为:为一个给定的终结符号串构建一颗语法分析树的过程
|->推导的形式太多了,咋解决?

---

最左推导和最右推导

如果在某个推导过程中的任何一步直接推导d=B中，都是对符号串a的最左（右）非终结符号进行替换，则称其为最左（右）推导。最右推导又叫做规范推导。由规范推导得到的句型称为规范句型。

---

递归

![[2-source-material/images/Pasted image 20251010091647.png]]

左递归,右递归

---

等价文法

两个文法产生的语言相同,则两个文法是等价文法

---

左右结合

左右结合体现为左右递归
优先级高的运算符更晚推导得到,处于语法树的更低层

## 实用限制

二义性

如果文法G的某个句子存在两棵（包括两棵）以上不同的语法树（即有两个不同的最左/最右推导），则称该文法是二义性文法。

文法二义性 != 语言二义性

二义性文法是不可判定的

---

文法的压缩

有害产生式:U->U
多余产生式:不可达非终结符号,无法推导出终结符号串
## Reference
